import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import { useAuth } from '../contexts/AuthContext';
import type { Database } from '../lib/database.types';
import toast from 'react-hot-toast';

type FixItBrief = Database['public']['Tables']['fix_it_briefs']['Row'];
type FixItBriefInsert = Database['public']['Tables']['fix_it_briefs']['Insert'];

interface FixItBriefWithQuery extends FixItBrief {
  query?: {
    id: string;
    query_text: string;
  };
}

export function useFixItBriefs() {
  const { user } = useAuth();
  const [briefs, setBriefs] = useState<FixItBriefWithQuery[]>([]);
  const [loading, setLoading] = useState(true);
  const [generating, setGenerating] = useState(false);

  useEffect(() => {
    if (user) {
      fetchBriefs();
    }
  }, [user]);

  const fetchBriefs = async () => {
    try {
      setLoading(true);
      const { data, error } = await supabase
        .from('fix_it_briefs')
        .select(`
          *,
          queries:query_id (
            id,
            query_text
          )
        `)
        .eq('user_id', user!.id)
        .order('created_at', { ascending: false });

      if (error) throw error;
      setBriefs(data || []);
    } catch (error) {
      console.error('Error fetching Fix-It briefs:', error);
      toast.error('Failed to load Fix-It briefs');
    } finally {
      setLoading(false);
    }
  };

  const generateBrief = async (queryId: string, customPrompt?: string) => {
    try {
      setGenerating(true);
      
      const { data, error } = await supabase.functions.invoke('generate-fix-it-brief', {
        body: {
          queryId,
          userId: user!.id,
          customPrompt
        }
      });

      if (error) throw error;

      if (data.success) {
        setBriefs(prev => [data.brief, ...prev]);
        toast.success('Fix-It brief generated successfully!');
        return data.brief;
      } else {
        throw new Error(data.error || 'Failed to generate brief');
      }
    } catch (error: any) {
      console.error('Error generating Fix-It brief:', error);
      toast.error(error.message || 'Failed to generate Fix-It brief');
      throw error;
    } finally {
      setGenerating(false);
    }
  };

  const updateBrief = async (briefId: string, updates: Partial<FixItBrief>) => {
    try {
      const { data, error } = await supabase
        .from('fix_it_briefs')
        .update(updates)
        .eq('id', briefId)
        .select(`
          *,
          queries:query_id (
            id,
            query_text
          )
        `)
        .single();

      if (error) throw error;

      setBriefs(prev => prev.map(b => b.id === briefId ? data : b));
      toast.success('Brief updated successfully');
    } catch (error: any) {
      console.error('Error updating brief:', error);
      toast.error(error.message || 'Failed to update brief');
    }
  };

  const deleteBrief = async (briefId: string) => {
    try {
      const { error } = await supabase
        .from('fix_it_briefs')
        .delete()
        .eq('id', briefId);

      if (error) throw error;

      setBriefs(prev => prev.filter(b => b.id !== briefId));
      toast.success('Brief deleted successfully');
    } catch (error: any) {
      console.error('Error deleting brief:', error);
      toast.error(error.message || 'Failed to delete brief');
    }
  };

  const downloadBrief = (brief: FixItBriefWithQuery) => {
    const content = `# Fix-It Brief: ${brief.title}

## Query Analysis
**Target Query:** ${brief.query?.query_text || 'Unknown'}
**Generated:** ${new Date(brief.created_at).toLocaleDateString()}

## SEO Optimization

### Title Tag
${brief.title}

### Meta Description
${brief.meta_description || 'Not provided'}

## Schema Markup
\`\`\`json
${brief.schema_markup || 'Not provided'}
\`\`\`

## Content Strategy
${brief.content_brief || 'Not provided'}

## FAQ Section
${(brief.faq_entries as any[])?.map((faq, index) => `
### ${index + 1}. ${faq.question}
${faq.answer}
**Keywords:** ${faq.keywords?.join(', ') || 'None'}
`).join('\n') || 'No FAQ entries provided'}

---
Generated by AEOlytics - AI Citation Analytics Platform
`;

    const blob = new Blob([content], { type: 'text/markdown' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `fix-it-brief-${brief.query?.query_text?.replace(/[^a-zA-Z0-9]/g, '-') || 'brief'}.md`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Update status to downloaded
    updateBrief(brief.id, { status: 'downloaded' });
  };

  return {
    briefs,
    loading,
    generating,
    generateBrief,
    updateBrief,
    deleteBrief,
    downloadBrief,
    refetch: fetchBriefs
  };
}